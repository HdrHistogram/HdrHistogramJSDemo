<html>
<head>
<meta charset="UTF-8">
<style type="text/css">
    div.histo {
        visibility: hidden
    }
</style>

<!--Load the AJAX API-->
<script type="text/javascript" src="https://www.google.com/jsapi"></script>
<script type="text/javascript" src="lib/pako.min.js"></script>
<script type="text/javascript" src="lib/hdrhistogram.min.js"></script>


<!--
 WARNING quick'n'dirty code down here :(
-->
<script type="text/javascript">

    if (window.File && window.FileReader && window.FileList && window.Blob) {
        // Great success! All the File APIs are supported.
    } else {
        alert('The File APIs are not fully supported in this browser.');
    }

    // Load the Visualization API and the piechart package.
    google.load('visualization', '1.0', {'packages':['corechart', 'annotationchart']});
    
    const parseUrl = searchString => {
        const equalIndex = searchString.indexOf('='); 
        if (equalIndex > 0) {
            return decodeURI(searchString.substring(equalIndex+1));
        }
        return 'https://raw.githubusercontent.com/HdrHistogram/HdrHistogramJS/master/test_files/jHiccup-2.0.7S.logV2.hlog';
    }

    var logs = null;

    // Set a callback to run when the Google Visualization API is loaded.
    google.setOnLoadCallback(function() {
        document.getElementById('files').addEventListener('change', handleFileSelect, false);
        const url = parseUrl(window.location.search);
        fetch(url).then(response => {
            response.text().then(content => {
                logs = content;
                displayLogs();
            });
        });
    });

    var chart = null;
    var maxChart = null;
    
    // initialized in jhiccup.log.example.js
    //var logs = null;

    var maxPercentile = 1000000;

    var latestChartData;
    function drawChart(chartData) {

        if (chartData) {
            latestChartData = chartData;
        } else {
            chartData = latestChartData;
        }

        var ticks =
                [{v:1,f:'0%'},
                    {v:10,f:'90%'},
                    {v:100,f:'99%'},
                    {v:1000,f:'99.9%'},
                    {v:10000,f:'99.99%'},
                    {v:100000,f:'99.999%'},
                    {v:1000000,f:'99.9999%'},
                    {v:10000000,f:'99.99999%'},
                    {v:100000000,f:'99.999999%'}];

        var unitSelection = document.getElementById("timeUnitSelection");
        var unitSelIndex = unitSelection.selectedIndex;
        var unitText = unitSelection.options[unitSelIndex].innerHTML;

        var options = {
            title: 'Latency by Percentile Distribution',
            height: 480,
            hAxis: {
                title: "Percentile",
                minValue: 1, logScale: true, ticks:ticks,
                viewWindowMode:'explicit',
                viewWindow:{
                    max:maxPercentile,
                    min:1
                }
            },
            vAxis: {title: 'Latency (' + unitText + ')', minValue: 0 },
            legend: {position: 'bottom'}
        };

        if (chart == null) {
            chart = new google.visualization.LineChart(document.getElementById('chart_div'));
        }

        // add tooptips with correct percentile text to data:
        var columns = [0];
        for (var i = 1; i < chartData.getNumberOfColumns(); i++) {
            columns.push(i);
            columns.push({
                type: 'string',
                properties: {
                    role: 'tooltip'
                },
                calc: (function (j) {
                    return function (dt, row) {
                        var percentile = 100.0 - (100.0/dt.getValue(row, 0));
                        return dt.getColumnLabel(j) + ': ' +
                                percentile.toPrecision(7) +
                                '\%\'ile = ' + dt.getValue(row, j) + ' ' + unitText
                    }
                })(i)
            });
        }
        var view = new google.visualization.DataView(chartData);
        view.setColumns(columns);

        chart.draw(view, options);

    }

    function drawMaxChart(tags, rawData) {
        var data = new google.visualization.DataTable();
        data.addColumn('datetime', 'Date');
        tags.forEach(tag => data.addColumn('number', tag));
        
        data.addRows(rawData);

        if (maxChart) {
            maxChart.clearChart();
        }

        maxChart = new google.visualization.AnnotationChart(document.getElementById('max_chart_div'));
        

        var options = {
          displayAnnotations: false,
          displayZoomButtons: false
        };

        maxChart.draw(data, options);

        google.visualization.events.addListener(maxChart, 'rangechange', debounce(rangechange_handler, 200));

        function debounce(callback, delay){
          var timer;
          return function(){
            var args = arguments;
            var context = this;
            clearTimeout(timer);
            timer = setTimeout(function(){
              callback.apply(context, args);
            }, delay)
          }
        }

        function rangechange_handler(e) {
          const data = parseLog(e.start, e.end);
          drawChart(data.histogram);
        }
      }


    function appendDataSeries(histo, name, dataSeries) {
        var series;
        var seriesCount;
        if (dataSeries.length == 0) {
            series = [ ['X', name] ];
            seriesCount = 1;
        } else {
            series = dataSeries;
            series[0].push(name);
            seriesCount = series[0].length - 1;
        }

        var lines = histo.split("\n");

        var seriesIndex = 1;
        for (var i = 0; i < lines.length; i++) {
            var line = lines[i].trim();
            var values = line.trim().split(/[ ]+/);

            if (line[0] != '#' && values.length == 4) {

                var y = parseFloat(values[0]);
                var x = parseFloat(values[3]);

                if (!isNaN(x) && !isNaN(y)) {

                    if (seriesIndex >= series.length) {
                        series.push([x]);
                    }

                    while (series[seriesIndex].length < seriesCount) {
                        series[seriesIndex].push(null);
                    }

                    series[seriesIndex].push(y);
                    seriesIndex++;
                }
            }
        }

        while (seriesIndex < series.length) {
            series[seriesIndex].push(null);
            seriesIndex++;
        }

        return series;
    }
    function timeUnitsSelected(evt) {
        drawChart();
    }

    const accumulatedHistograms = {}

    function parseLog(begin = new Date(0), end = new Date(8640000000000000)) {

        const beginParsing = performance.now();
        
        const reader = new hdr.HistogramLogReader(logs);
        const tags = hdr.listTags(logs);
        
        let latestMaxValues = {}
        tags.forEach(tag => {
            if (accumulatedHistograms[tag]) {
                accumulatedHistograms[tag].reset();
            } else {
                accumulatedHistograms[tag] = new hdr.Int32Histogram(1, Number.MAX_SAFE_INTEGER, 3);
            }
        });

        let histogram; 
        const rows = [];
        let latestTimeStampMsec; 
        
        while ((histogram = reader.nextIntervalHistogram()) != null) {
            if (!latestTimeStampMsec) {
                latestTimeStampMsec = histogram.startTimeStampMsec;
            }
            if (latestTimeStampMsec != histogram.startTimeStampMsec) {
                const row = [new Date(latestTimeStampMsec)];
                tags.forEach(tag => {
                    row.push(latestMaxValues[tag]); 
                });
                rows.push(row);
                latestMaxValues = {}
                latestTimeStampMsec = histogram.startTimeStampMsec;
            }
            const histogramDate = new Date(histogram.startTimeStampMsec); 
            if (begin <= histogramDate && histogramDate <= end) {
                accumulatedHistograms[histogram.tag].add(histogram);
                latestMaxValues[histogram.tag] = histogram.maxValue;
            }
        }

        if (Object.keys(latestMaxValues).length > 0) {
            const row = [new Date(latestTimeStampMsec)];
            tags.forEach(tag => {
                row.push(latestMaxValues[tag]); 
            });
            rows.push(row);
        }      

        let dataSeries = [];
        tags.forEach(tag => dataSeries = appendDataSeries(accumulatedHistograms[tag].outputPercentileDistribution(), tag, dataSeries));

        const chartData = google.visualization.arrayToDataTable(dataSeries);    

        const endParsing = performance.now();
        console.log("Process logs in ", (endParsing-beginParsing), "ms");

        return {
            tags,
            histogram: chartData,
            maxDataRows: rows
        }
    }

    function displayLogs() {
        const data = parseLog();
        drawChart(data.histogram);
        drawMaxChart(data.tags, data.maxDataRows);
    }

    function handleFileSelect(evt) {
        var files = evt.target.files; // FileList object

        var names = [];
        var histos = [];
        var fileCount = 0;

        // Loop through the FileList and render image files as thumbnails.
        for (var i = 0, f; f = files[i]; i++) {
            var reader = new FileReader();

            reader.onload = (function(theFile) {
                return function(e) {
                    logs = e.target.result;
                    displayLogs();
                };
            })(f);

            // Read in the image file as a data URL.
            reader.readAsText(f);
        }

    }

 
</script>

<style>
    .slider-width500
    {
        width: 500px;
    }
</style>

</head>

<body>
<h2>HdrHistogram simple log analyzer</h2>

<input type="file" id="files" name="files[]" multiple />


<div id="max_chart_div" style="height: 200px"></div>
<div style="height: 300px"> 
<div id="chart_div" > >None Loaded</div>

Latency time units:
<select name="units" size="1" id="timeUnitSelection" onChange="timeUnitsSelected()">
    <option value="Latency (seconds)">seconds</option>
    <option selected value="Latency (milliseconds)">milliseconds</option>
    <option value="Latency (µs)">microseconds</option>
    <option value="Latency (nanoseconds)">nanoseconds</option>
</select>

&nbsp; &nbsp; &nbsp; &nbsp;
<p>
Percentile range:

<input type="range" class="slider-width500"
       min="1" max="8" value="7" step="1"
       width="300px"
       onchange="showValue(this.value)" />
<span id="percentileRange">99.99999%</span>
<script type="text/javascript">
    function showValue(newValue) {
        var x = Math.pow(10, newValue);
        percentile = 100.0 - (100.0 / x);
        document.getElementById("percentileRange").innerHTML=percentile + "%";
        maxPercentile = x;
        drawChart();
    }
</script>
</p>
</div>
</body>
</html>
